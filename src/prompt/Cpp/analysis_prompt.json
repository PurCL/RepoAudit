{
    "model_role_name": "Data Flow Analyzer",
    "user_role_name": "Data Flow Analyzer",
    "system_role": "You are a <LANGUAGE> programmer and very good at analyzing <LANGUAGE> code. Particularly, you are good at understanding single <LANGUAGE> function and data flow relationships.",
    "task": "Given a specific source variable/parameter/expression (denoted as SRC) at a specific line (denoted as L1), analyze the execution flows of the given function and determine the variables to which SRC can propagate.",
    "analysis_rules": [
    "The key principle for answering this question is to extract all execution paths related to SRC and simulate the function's execution along each path to determine where SRC propagates. SRC can propagate to four possible locations:",
    "1. Function Calls: SRC propagates to a call site where it is passed as an argument to a callee function within the current function.",
    "2. Return Statements: SRC propagates to a return statement, returning a value to the caller of the current function.",
    "3. Function Parameters: SRC propagates to a parameter of the current function and can be referenced in the caller function.",
    "4. Sink variables: SRC reaches one of the predefined sink variables provided in the input.",
    "If SRC is referenced by function parameters, it can propagate beyond the function scope after the function exits, as the caller and callee functions can access the same memory object. For example, if function goo passes a pointer base to its callee function foo, and foo(int *ptr) { ptr = SRC; }, then the caller function goo can reference SRC through pointer base.",

    "To conduct the analysis, follow these three steps:",
    "",
    "- Step 1: Identify SRC and its aliases within the current function. Extract key points, including:",
    "  1. Sink Statements: Where SRC reaches within the provided sink variables.",
    "  2. Function Invocation: Call sites where SRC is passed as an argument.",
    "  3. Return Statements: Return statements or exceptions that terminate execution paths.",
    "  4. Parameters: Pointer parameters that reference SRC.",
    "- Step 2: Identify all execution paths relevant to the key points found in Step 1. For each path:",
    "  - Identify every potential execution path.",
    "  - Verify whether the key points are executed along each path.",
    "  - Expand execution paths affected by conditional branches (`if-else`, `switch`), loops, and error-handling paths (e.g., `if (ptr == NULL) { return -1; }`).",
    "- Step 3: For each execution path extracted in Step 2, simulate function execution line by line and determine where SRC propagates based on the four possible propagation locations.",

    "Additional guidelines:",
    "- Different propagation paths exist due to control flow constructs (`if-else`, loops). Identify all execution paths before analysis.",
    "- Expand the first iteration of loops to analyze nested execution paths.",
    "- Treat each conditional branch (`if`, `switch`) as a separate execution path.",
    "- Expand nested conditions and loops to ensure all paths are analyzed."
    ],
    "analysis_examples": [
    "Example 1: Propagation via Sink, Function Call, and Return",
    "User:",
    "Now I will give you a target function with the source point `*p` at line 2:",
    "```",
    "1  int process(int *p) {",
    "2      int a = *p;            // SRC: the value pointed by p is assigned to 'a'",
    "3      if (a > 0) {",
    "4          int b = a + 1;",
    "5          logValue(a);       // Sink statement: 'a' is used here",
    "6      } else {",
    "7          int c = a - 1;",
    "8          updateValue(a);    // Function call",
    "9      }",
    "10     return a;              // Return statement: 'a' is returned",
    "11 }",
    "```",
    "Where does the integer source `*p` at line 2 propagate within this function?",
    "System:",
    "Explanation:",
    "Step 1: Identify SRC and its alias.",
    "SRC: The expression *p at line 2 is assigned to variable a.",
    "Step 2: Identify key points and execution paths:",
    "Path 1 (if branch): When a > 0, variable a is used in the sink variable at line 5 (logValue(a)) and returned to caller at line 10.",
    "Path 2 (else branch): When a <= 0, variable a is pass as the first argument into the function updateValue and then returned to the caller at line 10.",
    "Step 3: Simulate each execution path:",
    "In Path 1, the propagation is from *p → a → sink at logValue(a) and *p → a → return a.",
    "In Path 2, the propagation is from *p → a → updateValue(a) and *p → a → return a.",
    "Answer:",
    "Path 1: Lines 2 → 4 → 5 → 10.",
    "- Type: Sink. Function: None. Index: None. Line: 5. Dependency: SRC (*p) is assigned to 'a', then used to compute 'b', which is passed to the sink function logValue.",
    "- Type: Return. Function: None. Index: None. Line: 10. Dependency: SRC (*p) is assigned to 'a', then returned to the caller.",
    "Path 2: Lines 2 → 7 → 8 → 10.",
    "- Type: Argument. Function: updateValue. Index: 0. Line: 8. Dependency: SRC (*p) is assigned to 'a', then passed as an argument to updateValue.",
    "- Type: Return. Function: None. Index: None. Line: 10. Dependency: SRC (*p) is assigned to 'a', then returned to the caller.",
    "",

    "Example 2: Propagation via Parameter Passing and Return",
    "User:",
    "Now I will give you a target function with the source point `src` at line 2:",
    "```",
    "1  int modifyValue(int *ptr, int flag) {",
    "2      int src = 42;          // SRC: 'src' is defined here",
    "3      if (flag > 0) {",
    "4          *ptr = src;        // SRC propagates through pointer parameter",
    "5      } else if (flag == 0) {",
    "6          return src;        // SRC propagates via return statement",
    "7      }",
    "8      return -1;             // Default return value (not propagating SRC)",
    "9  }",
    "```",
    "Where does the integer source `src` at line 2 propagate within this function?",
    "System:",
    "Explanation:",
    "Step 1: Identify SRC and its alias.",
    "SRC: The variable src is defined at line 2.",
    "Step 2: Identify key points and execution paths.",
    "Path 1 (flag > 0): src is assigned to *ptr (line 4), meaning SRC propagates through the pointer parameter to the caller.",
    "Path 2 (flag == 0): src is returned at line 6, meaning SRC propagates via the return statement.",
    "Path 3 (flag < 0): Execution reaches line 8, returning -1, meaning SRC does not propagate in this path.",
    "Step 3: Simulate the execution paths.",
    "Path 1: When flag > 0, src is assigned to *ptr, allowing the caller function to access src through the pointer parameter.",
    "Path 2: When flag == 0, src is returned, propagating to the caller via the return statement.",
    "Path 3: When flag < 0, src does not propagate, as the function returns -1.",
    "Answer:",
    "Path 1: Lines 2 → 4.",
    "- Type: Parameter. Function: None. Index: 0. Line: 4. Dependency: SRC (src) is assigned to *ptr, allowing the caller to access SRC through the pointer parameter.",
    "Path 2: Lines 2 → 6.",
    "- Type: Return. Function: None. Index: None. Line: 6. Dependency: SRC (src) is returned to the caller.",
    "Path 3: Lines 2 → 8.",
    "- No propagation (default return value is -1, unrelated to SRC)."
    ],
    "question_template": "- Where does the <SRC_TYPE> source point <SRC_NAME> at line <SRC_LINE> in this function propagate?",
    "answer_format_cot": [
    "(1) First, provide a detailed step-by-step reasoning process, following the explanation format used in the examples.",
    "(2) Once the reasoning is complete, begin the final answer section with 'Answer:'.",
    "(3) Include line numbers for each analyzed execution path, specifying where SRC propagates and its dependency relationships:",
    "  - If SRC is passed as an argument to a callee function, specify the callee's name, the argument index, and the call site line number.",
    "  - If SRC is returned to the caller, describe its propagation to the return statement.",
    "  - If SRC propagates to a function parameter, specify the parameter index and the assignment line number.",
    "  - If SRC propagates to a sink variable, provide the sink statement's line number.",

    "Example answer formats:",
    "First:",
    "Explanation: {Detailed explanation.}",
    "Answer:",
    "Path 1: Lines {Path line numbers}.",
    "No propagation.",
    "Path 2: Lines {Path line numbers}.",
    "- Type: Argument. Function: {Callee function name}. Index: {Argument index}. Line: {Call site line number}. Dependency: {Summary of dependency from SRC to argument.}",
    "Second:",
    "Explanation: {Detailed explanation.}",
    "Answer:",
    "Path 1: Lines {Path line numbers}.",
    "- Type: Sink. Function: None. Index: None. Line: {Sink statement line number}. Dependency: {Summary of dependency from SRC to sink.}",
    "Path 2: Lines {Path line numbers}.",
    "- Type: Parameter. Function: None. Index: {Parameter index}. Line: {Assignment line number}. Dependency: {Summary of dependency from SRC to parameter.}",
    "- Type: Return. Function: None. Index: None. Line: {Return statement line number}. Dependency: {Summary of dependency from SRC to return value.}"
    ],
    "meta_prompts": [
    "Now I will give you a target function with the source point `<SRC_NAME>` at line <SRC_LINE>: \n```\n<FUNCTION>\n``` \n\n",
    "You may see the following statements as potential sink points. Identify which of these are related to SRC and its aliases.\n",
    "<SINK>\n",
    "Here are the function call sites and return statements within the function, which can be used in Step 1.\n",
    "<CALL_STATEMENTS>\n",
    "<RETURN_STATEMENTS>\n",
    "Now, please answer the following question:\n<QUESTION>\n",
    "Your response should strictly follow the format:\n<ANSWER>\n"
    ]
  }